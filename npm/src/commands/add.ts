/**
 * `aerostack add <slug>` — The Game Changer
 * 
 * Downloads a community function from the registry and wires it into
 * your project automatically.
 * 
 * What it does:
 *   1. Fetches the install manifest from the registry API
 *   2. Places all source files into src/modules/<name>/ or src/lib/<name>/
 *   3. Patches src/index.ts with the import + app.route() call
 *   4. (Optional) Generates a Node.js adapter
 *   5. Prints next steps (drizzle-kit push, env vars to set)
 * 
 * Usage:
 *   npx aerostack add stripe-checkout
 *   npx aerostack add alice/stripe-checkout
 *   npx aerostack add stripe-checkout --runtime=node
 *   npx aerostack add stripe-checkout --registry=http://localhost:8787/api
 */

import chalk from 'chalk';
import ora from 'ora';
import { mkdirSync, writeFileSync, existsSync } from 'fs';
import { join, resolve } from 'path';
import { execSync } from 'child_process';
import { fetchInstallManifest, DEFAULT_REGISTRY, type FunctionManifest } from '../lib/registry.js';
import { injectRoute, injectSchema } from '../lib/injector.js';

function parseArgs(args: string[]) {
    const slug = args.find(a => !a.startsWith('--'));
    const flags: Record<string, string> = {};
    for (const arg of args) {
        if (arg.startsWith('--')) {
            const [key, val] = arg.slice(2).split('=');
            flags[key] = val || 'true';
        }
    }
    return { slug, flags };
}

function toPascalCase(str: string): string {
    return str.split(/[-_]/).map(s => s[0]?.toUpperCase() + s.slice(1)).join('');
}

function toCamelCase(str: string): string {
    const p = toPascalCase(str);
    return p[0].toLowerCase() + p.slice(1);
}

function generateNodeAdapter(manifest: FunctionManifest, moduleName: string): string {
    const pascal = toPascalCase(moduleName);
    const camel = toCamelCase(moduleName);
    const coreFile = manifest.files.find(f => f.path === 'core.ts');
    const hasSchema = manifest.drizzleSchema;

    // Extract exported function names from core.ts if available
    let coreImports = '// import { yourFunction } from \'./core\';';
    if (coreFile) {
        const exports = Array.from(coreFile.content.matchAll(/^export (?:async )?function (\w+)/gm))
            .map(m => m[1]);
        if (exports.length > 0) {
            coreImports = `import { ${exports.join(', ')} } from './core';`;
        }
    }

    return `/**
 * ${moduleName}/node-adapter.ts — Node.js / Express Adapter
 * 
 * Generated by Aerostack CLI. Do not edit directly.
 * 
 * This adapter wraps the platform-agnostic core.ts functions
 * for use in Node.js + Express applications.
 * 
 * Usage:
 *   import { create${pascal}Router } from './modules/${moduleName}/node-adapter';
 *   app.use('/api/${moduleName}', create${pascal}Router(db));
 */
import { Router } from 'express';
${hasSchema ? "import { drizzle } from 'drizzle-orm/node-postgres';" : ''}
${hasSchema ? "import * as schema from './schema';" : ''}
${coreImports}

export function create${pascal}Router(d1OrPgClient: any) {
    const router = Router();
${hasSchema ? `    const db = typeof d1OrPgClient?.prepare === 'function'
        ? drizzle(d1OrPgClient, { schema }) // SQLite/D1
        : drizzle(d1OrPgClient, { schema }); // PostgreSQL
` : ''}

    // TODO: Mount your core function calls here
    // Example:
    // router.get('/', async (req, res) => {
    //     const result = await yourFunction({ db }, req.query);
    //     res.json(result);
    // });

    router.get('/health', (_req, res) => res.json({ module: '${moduleName}', ok: true }));

    return router;
}

export { create${pascal}Router as ${camel}Router };
`;
}

export async function addCommand(args: string[]) {
    const { slug, flags } = parseArgs(args);

    if (!slug) {
        console.error(chalk.red('\n  Usage: npx aerostack add <function-name>\n'));
        console.log(chalk.gray('  Example: npx aerostack add stripe-checkout\n'));
        process.exit(1);
    }

    const registry = flags['registry'] || DEFAULT_REGISTRY;
    const runtime = flags['runtime'] || 'cloudflare'; // 'cloudflare' | 'node'
    const dryRun = flags['dry-run'] === 'true';
    const projectRoot = resolve(process.cwd());

    console.log(`\n${chalk.bold.blue('  ⚡ Aerostack Add')}\n`);
    console.log(`  Installing ${chalk.cyan(slug)} from registry...\n`);

    // ─── Step 1: Fetch install manifest ──────────────────────────────────────
    const spinner = ora(`Fetching "${slug}" from registry`).start();
    let manifest: FunctionManifest;
    try {
        manifest = await fetchInstallManifest(registry, slug);
        spinner.succeed(`Found: ${chalk.bold(manifest.name)} by ${chalk.cyan(manifest.author)} ${chalk.gray(`v${manifest.version}`)}`);
    } catch (err: any) {
        spinner.fail(err.message);
        process.exit(1);
    }

    const moduleName = manifest.slug;
    const moduleType = manifest.type || 'feature'; // 'feature' → src/modules/, 'utility' → src/lib/
    const moduleDir = moduleType === 'utility'
        ? join(projectRoot, 'src', 'lib', moduleName)
        : join(projectRoot, 'src', 'modules', moduleName);

    // ─── Step 2: Write source files ──────────────────────────────────────────
    const writeSpinner = ora('Writing source files').start();
    try {
        if (!dryRun) {
            mkdirSync(moduleDir, { recursive: true });

            for (const file of manifest.files) {
                const filePath = join(moduleDir, file.path);
                writeFileSync(filePath, file.content, 'utf-8');
            }

            // Write aerostack-manifest.json (for publish command to read later)
            writeFileSync(
                join(moduleDir, 'aerostack-manifest.json'),
                JSON.stringify({
                    id: manifest.id,
                    name: manifest.name,
                    slug: manifest.slug,
                    author: manifest.author,
                    version: manifest.version,
                    type: manifest.type,
                    routeExport: manifest.routeExport,
                    routePath: manifest.routePath,
                    drizzleSchema: manifest.drizzleSchema,
                    npmDependencies: manifest.npmDependencies || [],
                    envVars: manifest.envVars || [],
                    installedAt: new Date().toISOString(),
                }, null, 2),
                'utf-8'
            );

            // Optionally generate node adapter
            if (runtime === 'node') {
                const nodeAdapterContent = generateNodeAdapter(manifest, moduleName);
                writeFileSync(join(moduleDir, 'node-adapter.ts'), nodeAdapterContent, 'utf-8');
            }
        }
        writeSpinner.succeed(`Files placed in ${chalk.cyan(`src/${moduleType === 'utility' ? 'lib' : 'modules'}/${moduleName}/`)}`);
    } catch (err: any) {
        writeSpinner.fail(`Failed to write files: ${err.message}`);
        process.exit(1);
    }

    // ─── Step 3: Patch src/index.ts ──────────────────────────────────────────
    if (moduleType === 'feature' && manifest.routeExport && manifest.routePath) {
        const injectSpinner = ora('Patching src/index.ts').start();
        const indexPath = join(projectRoot, 'src', 'index.ts');
        const relPath = `./modules/${moduleName}/adapter`;
        const importStmt = `import { ${manifest.routeExport} } from '${relPath}';`;
        const routeStmt = `app.route('${manifest.routePath}', ${manifest.routeExport});`;

        if (!dryRun && existsSync(indexPath)) {
            const result = injectRoute(indexPath, {
                importStatement: importStmt,
                routeStatement: routeStmt,
            });
            if (result.modified) {
                injectSpinner.succeed('src/index.ts patched');
            } else {
                injectSpinner.info(`src/index.ts: ${result.reason}`);
            }
        } else if (!existsSync(indexPath)) {
            injectSpinner.warn('src/index.ts not found — add these manually:');
            console.log(chalk.gray(`\n    ${importStmt}`));
            console.log(chalk.gray(`    ${routeStmt}\n`));
        } else {
            injectSpinner.succeed('src/index.ts (dry run — would inject)');
        }
    }

    // ─── Step 4: Patch src/db/schema.ts ──────────────────────────────────────
    if (manifest.drizzleSchema) {
        const schemaPath = join(projectRoot, 'src', 'db', 'schema.ts');
        if (!dryRun && existsSync(schemaPath)) {
            const relPath = `../modules/${moduleName}/schema`;
            injectSchema(schemaPath, {
                importStatement: `import * as ${toCamelCase(moduleName)}Schema from '${relPath}';`,
                exportStatement: `export * from '${relPath}';`,
            });
        }
    }

    // ─── Step 5: Install npm dependencies ────────────────────────────────────
    if (manifest.npmDependencies && manifest.npmDependencies.length > 0) {
        const depsSpinner = ora(`Installing npm deps: ${manifest.npmDependencies.join(', ')}`).start();
        if (!dryRun) {
            try {
                execSync(`npm install ${manifest.npmDependencies.join(' ')}`, {
                    cwd: projectRoot,
                    stdio: 'pipe',
                });
                depsSpinner.succeed(`npm packages installed`);
            } catch {
                depsSpinner.warn(`npm install failed — run manually: npm install ${manifest.npmDependencies.join(' ')}`);
            }
        } else {
            depsSpinner.succeed('(dry run)');
        }
    }

    // ─── Done ─────────────────────────────────────────────────────────────────
    console.log(`\n${chalk.green('  ✓ Done!')} ${chalk.bold(manifest.name)} is installed.\n`);

    const nextSteps: string[] = [];
    if (manifest.drizzleSchema) {
        nextSteps.push(`${chalk.gray('→')} Apply schema: ${chalk.cyan('npx drizzle-kit push')}`);
    }
    if (manifest.envVars && manifest.envVars.length > 0) {
        nextSteps.push(`${chalk.gray('→')} Add to wrangler.toml [vars] or .env:`);
        for (const v of manifest.envVars) {
            nextSteps.push(`    ${chalk.yellow(v)}=your_value`);
        }
    }
    if (manifest.routePath) {
        nextSteps.push(`${chalk.gray('→')} Route available at: ${chalk.cyan(manifest.routePath)}`);
    }
    if (runtime === 'node') {
        nextSteps.push(`${chalk.gray('→')} Node adapter: ${chalk.cyan(`src/modules/${moduleName}/node-adapter.ts`)}`);
    }

    if (nextSteps.length > 0) {
        console.log(chalk.bold('  Next steps:'));
        for (const step of nextSteps) {
            console.log(`  ${step}`);
        }
        console.log();
    }

    console.log(`  ${chalk.gray('View source:')} ${chalk.underline(`https://hub.aerostack.dev/functions/${manifest.author}/${manifest.slug}`)}\n`);
}
